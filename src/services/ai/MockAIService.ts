/**
 * MockAIService.ts
 * Implements a mock AI service for demo and testing
 */

import { AIServiceOptions, AIServiceResponse, BaseAIService } from './AIService';

// Predefined responses for various common prompts
const MOCK_RESPONSES: Record<string, string[]> = {
  // General completions
  'default': [
    'Here is some example text that could be generated by an AI assistant. This response is meant to simulate real AI output for demonstration purposes.',
    'I can provide information on a wide range of topics, including science, history, technology, and more. What specific information are you looking for?',
    'This is a simulated AI response for demonstration purposes. In a real implementation, this would connect to an actual AI service API.'
  ],
  
  // Explain responses
  'explain': [
    'This concept refers to the foundational principles that govern how systems interact and operate. It encompasses both theoretical frameworks and practical applications that have evolved over time.',
    'This is a complex topic with multiple dimensions. At its core, it involves the systematic analysis of structures and patterns to derive meaningful insights and practical solutions.',
    'The subject can be understood through its historical development and contemporary applications. It emerged as a response to specific challenges and has since evolved into a comprehensive framework.'
  ],
  
  // Summarize responses
  'summarize': [
    'The text discusses key developments in the field, highlighting recent innovations and their potential impact on future applications. It emphasizes the importance of interdisciplinary approaches.',
    'The content covers essential aspects of the topic, focusing on methodological considerations and practical implications. It synthesizes diverse perspectives into a coherent framework.',
    'The document presents an overview of the main arguments, supporting evidence, and conclusions. It identifies areas of consensus as well as unresolved questions that warrant further investigation.'
  ],
  
  // Expand responses
  'expand': [
    'Building on the initial concept, we can explore multiple dimensions of this topic. First, let's consider the historical context that shaped its development. Originally conceived as a response to specific challenges, it has evolved through several distinct phases, each characterized by particular innovations and limitations. Second, the theoretical framework encompasses various complementary and sometimes competing models, each with its own explanatory power and domain of application. Third, practical implementations have demonstrated both the versatility and constraints of these approaches across different contexts and use cases. Furthermore, recent advancements have opened new possibilities that warrant exploration and critical assessment.',
    'We can elaborate on this subject by examining several key aspects. The foundational principles establish the conceptual boundaries and operative mechanisms that define its essential nature. These principles have been refined through empirical testing and theoretical critique, resulting in a more nuanced understanding. Additionally, the methodological approaches vary according to specific objectives and contextual factors, with each approach offering distinct advantages and limitations. The practical applications span diverse domains, from specialized technical implementations to broader social and organizational contexts. Finally, emerging trends suggest promising directions for future development and research, particularly regarding integration with complementary systems and adaptation to evolving requirements.',
    'Delving deeper into this topic reveals its multifaceted nature. At its core, it addresses fundamental questions about structure, function, and process that transcend specific implementations. The historical evolution demonstrates how initial formulations have been continuously refined and sometimes radically reconceptualized in response to new challenges and insights. Theoretical frameworks provide analytical tools for understanding complex interactions and predicting outcomes under various conditions. Methodological considerations inform best practices for implementation and evaluation, while also acknowledging constraints and trade-offs. Current research continues to expand the boundaries of what's possible, exploring novel approaches and applications that may fundamentally transform our understanding of the field.'
  ],
  
  // Rewrite responses
  'rewrite': [
    'This revised version improves clarity and concision while preserving the essential meaning. It employs more precise terminology and a more logical structure to enhance reader comprehension.',
    'The reformulated text maintains the core message while adopting a more engaging and accessible style. Technical terms are clearly defined, and complex ideas are illustrated with relevant examples.',
    'This alternative presentation reorganizes the content to emphasize key points and strengthen the overall narrative. It eliminates redundancies and resolves ambiguities present in the original text.'
  ]
};

/**
 * A mock implementation of the AI service for demonstration purposes
 */
export class MockAIService extends BaseAIService {
  private responseDelay: number;
  
  constructor(options?: AIServiceOptions & { responseDelay?: number }) {
    super(options);
    this.responseDelay = options?.responseDelay || 500;
  }
  
  async generateCompletion(prompt: string, options?: AIServiceOptions): Promise<AIServiceResponse> {
    const controller = this.createAbortController();
    
    try {
      // Add artificial delay to simulate network request
      await this.delay(this.responseDelay);
      
      // Check if aborted
      if (controller.signal.aborted) {
        throw new Error('Request was cancelled');
      }
      
      // Determine which response category to use
      const category = this.determineCategory(prompt);
      
      // Get responses for that category
      const responses = MOCK_RESPONSES[category] || MOCK_RESPONSES.default;
      
      // Select a random response
      const content = responses[Math.floor(Math.random() * responses.length)];
      
      // Calculate mock token usage
      const promptTokens = Math.ceil(prompt.length / 4);
      const completionTokens = Math.ceil(content.length / 4);
      
      return {
        content,
        usage: {
          promptTokens,
          completionTokens,
          totalTokens: promptTokens + completionTokens
        },
        metadata: {
          model: options?.model || this.options.model,
          category,
          mockResponse: true
        }
      };
    } finally {
      this.removeAbortController(controller);
    }
  }
  
  async generateEdit(input: string, instruction: string, options?: AIServiceOptions): Promise<AIServiceResponse> {
    const controller = this.createAbortController();
    
    try {
      // Add artificial delay
      await this.delay(this.responseDelay);
      
      // Check if aborted
      if (controller.signal.aborted) {
        throw new Error('Request was cancelled');
      }
      
      // Get a rewrite response
      const responses = MOCK_RESPONSES.rewrite;
      const content = responses[Math.floor(Math.random() * responses.length)];
      
      // Add edited version of the input based on the instruction
      let editedContent = input;
      
      // Simple mock edits based on common instructions
      if (instruction.toLowerCase().includes('shorter') || instruction.toLowerCase().includes('summarize')) {
        // Create a shorter version
        editedContent = input.split(' ').slice(0, Math.ceil(input.split(' ').length / 2)).join(' ');
      } else if (instruction.toLowerCase().includes('longer') || instruction.toLowerCase().includes('expand')) {
        // Create a longer version
        editedContent = input + ' ' + input;
      } else if (instruction.toLowerCase().includes('formal')) {
        // Mock formal rewrite
        editedContent = input.replace(/(?:^|\s)i(?:\s|$)/g, ' one ').replace(/don't/g, 'do not').replace(/can't/g, 'cannot');
      } else if (instruction.toLowerCase().includes('casual')) {
        // Mock casual rewrite
        editedContent = input.replace(/\./g, '! ').replace(/,/g, '... ');
      }
      
      // Calculate mock token usage
      const promptTokens = Math.ceil((input.length + instruction.length) / 4);
      const completionTokens = Math.ceil(editedContent.length / 4);
      
      return {
        content: editedContent,
        usage: {
          promptTokens,
          completionTokens,
          totalTokens: promptTokens + completionTokens
        },
        metadata: {
          model: options?.model || this.options.model,
          instruction,
          mockResponse: true
        }
      };
    } finally {
      this.removeAbortController(controller);
    }
  }
  
  async analyzeText(content: string, analysisType: string, options?: AIServiceOptions): Promise<AIServiceResponse> {
    const controller = this.createAbortController();
    
    try {
      // Add artificial delay
      await this.delay(this.responseDelay);
      
      // Check if aborted
      if (controller.signal.aborted) {
        throw new Error('Request was cancelled');
      }
      
      let result: string;
      
      // Mock different analysis types
      switch (analysisType.toLowerCase()) {
        case 'sentiment':
          result = JSON.stringify({
            sentiment: Math.random() > 0.5 ? 'positive' : 'negative',
            score: Math.random(),
            confidence: 0.7 + Math.random() * 0.3
          });
          break;
          
        case 'summary':
          const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
          const summaryLength = Math.max(1, Math.floor(sentences.length / 3));
          result = sentences.slice(0, summaryLength).join('. ') + '.';
          break;
          
        case 'entities':
          // Mock entity extraction
          const words = content.split(/\s+/).filter(w => w.length > 4);
          const entities = words
            .filter(() => Math.random() > 0.7)
            .slice(0, 5)
            .map(word => ({
              text: word,
              type: ['PERSON', 'LOCATION', 'ORGANIZATION', 'DATE', 'PRODUCT'][Math.floor(Math.random() * 5)],
              confidence: 0.6 + Math.random() * 0.4
            }));
          result = JSON.stringify({ entities });
          break;
          
        default:
          result = `Analysis of type "${analysisType}" completed successfully. This is a mock result.`;
      }
      
      // Calculate mock token usage
      const promptTokens = Math.ceil(content.length / 4);
      const completionTokens = Math.ceil(result.length / 4);
      
      return {
        content: result,
        usage: {
          promptTokens,
          completionTokens,
          totalTokens: promptTokens + completionTokens
        },
        metadata: {
          model: options?.model || this.options.model,
          analysisType,
          mockResponse: true
        }
      };
    } finally {
      this.removeAbortController(controller);
    }
  }
  
  override getCapabilities() {
    return {
      supportsStreaming: false,
      supportedModels: ['default', 'creative', 'precise'],
      maxTokens: 4096,
      supportedAnalysisTypes: ['sentiment', 'summary', 'entities', 'keywords']
    };
  }
  
  /**
   * Creates an artificial delay to simulate network requests
   */
  private async delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  /**
   * Determines which response category to use based on the prompt
   */
  private determineCategory(prompt: string): string {
    const normalizedPrompt = prompt.toLowerCase();
    
    if (normalizedPrompt.includes('explain') || normalizedPrompt.includes('what is') || normalizedPrompt.includes('how does')) {
      return 'explain';
    }
    
    if (normalizedPrompt.includes('summarize') || normalizedPrompt.includes('summary')) {
      return 'summarize';
    }
    
    if (normalizedPrompt.includes('expand') || normalizedPrompt.includes('elaborate') || normalizedPrompt.includes('more detail')) {
      return 'expand';
    }
    
    if (normalizedPrompt.includes('rewrite') || normalizedPrompt.includes('rephrase') || normalizedPrompt.includes('revise')) {
      return 'rewrite';
    }
    
    return 'default';
  }
}
